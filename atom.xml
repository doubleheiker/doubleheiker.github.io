<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>asKylin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-07T14:45:03.869Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>doubleheiker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Assembly language</title>
    <link href="http://yoursite.com/2018/09/03/Assembly-language/"/>
    <id>http://yoursite.com/2018/09/03/Assembly-language/</id>
    <published>2018-09-03T11:18:35.000Z</published>
    <updated>2018-09-07T14:45:03.869Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>·汇编语言的组成（3类指令）</strong></p><p>1）汇编指令：有对应的机器码。<br>2）伪指令：没有对应的机器码，由编译器执行。<br>3）其他符号：如+、-、*、/等，没有对应的机器码，由编译器执行。</p><p><strong>·CPU对存储器的读写</strong></p><p>与芯片进行3类信息的交互：<br>1）存储单元地址。<br>2）器件选择，读或写命令。<br>3）读或写的数据。</p><p><strong>·外部总线</strong></p><p>1）地址总线：N根地址线可以选找2的N次方个内存单元（一个内存单元1byte）。<br>2）数据总线：宽度为8k的总线一次能传送 k Btye的数据。<br>3）控制总线：宽度决定CPU对外部期间的控制能力。</p><p><strong>·存储器芯片</strong></p><p>1）随机存储（RAM）：可读可写，关机数据丢失。<br>2）只读存储（ROM）：只读，关机数据不丢失。</p><hr><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><strong>·Registers Architecture(寄存器结构)</strong></p><style>table th:nth-of-type(2) {    width: 100px;}table th:nth-of-type(3) {    width: 60px;}table th:nth-of-type(9) {    width: 80px;}</style> <table><thead><tr><th>register</th><th style="text-align:center">Accumulator</th><th>Counter</th><th>Data</th><th>Base</th><th>Stack Pointer</th><th>Stack Base Pointer</th><th>Source</th><th>Destination</th></tr></thead><tbody><tr><td>64-bit</td><td style="text-align:center">RAX</td><td>RCX</td><td>RDX</td><td>RBX</td><td>RSP</td><td>RBP</td><td>RSI</td><td>RCI</td></tr><tr><td>32-bit</td><td style="text-align:center">EAX</td><td>ECX</td><td>EDX</td><td>EBX</td><td>ESP</td><td>EBP</td><td>ESI</td><td>EDI      </td></tr><tr><td>16-bit</td><td style="text-align:center">AX</td><td>CX</td><td>DX</td><td>BX</td><td>SP</td><td>BP</td><td>SI</td><td>DI</td></tr><tr><td> 8-bit</td><td style="text-align:center">AH/AL</td><td>CH/CL</td><td>DH/DL</td><td>BH/BL</td></tr></tbody></table><p><strong>·通用寄存器</strong></p><p>1）AX BX CX DX 这四个寄存器存放一般性数据。<br>2）这四个通用寄存器都可以分为两个八位寄存器使用（参见上表16-bit和8-bit）<br>   其中，低八位构成AL，高八位构成AH。</p><p><strong>·几条汇编指令</strong></p><p>1）汇编指令举例</p><style>table th:first-of-type {    width: 100px;}table th:nth-of-type(2) {    width: 100px;}</style> <table><thead><tr><th>汇编指令</th><th style="text-align:center">控制CPU完成的操作</th></tr></thead><tbody><tr><td>mov ax,18</td><td style="text-align:center">AX=18</td></tr><tr><td>mov ah,78</td><td style="text-align:center">AH=78</td></tr><tr><td>mov al,8</td><td style="text-align:center">AL=8</td></tr><tr><td>add ax,9</td><td style="text-align:center">AX+=9</td></tr><tr><td>mov ax,bx</td><td style="text-align:center">AX=BX</td></tr><tr><td>mov al,bh</td><td style="text-align:center">AL=BH</td></tr><tr><td>add ax,bx</td><td style="text-align:center">AX+=BX</td></tr><tr><td>add bh,al</td><td style="text-align:center">BH+=AL</td></tr></tbody></table><p>2）注意事项：<br>   16位寄存器中，若是数据值相加超过4位十六进制的数据，则只保存低四位的十六进制数据。<br>   当16位寄存器被用作两个八位寄存器时，若寄存器数据值超过两位十六进制的数据，则只保存低二位的十六进制数据（若是AL寄存器中数据超过内存，高位不是真的被CPU丢失）<br>   指令的两个操作对象的位数应该一致，而：<br>      mov ax,bl<br>      mov bh,ax<br>      mov al,2000（超出范围）<br>      add al,100H（超出范围）<br>   都是错误的指令。</p><p><strong>·8086CPU给出物理地址的方法</strong></p><p>1）地址加法器采用<strong>物理地址 = 段地址x16 + 偏移地址</strong>的方法（地址数据用16进制表示）。<br>2）基础地址 = 段地址 x 16。<br>3）“段地址x16”实际上表示16进制数左移一位（即二进制数左移4位）。</p><p><strong>·段地址</strong></p><p>1）“段地址”划分来自CPU，不是内存本身分段。<br>2）CPU可以用不同的段地址和偏移地址形成同一个物理地址。<br>3）给定段地址，仅用偏移地址寻址最多可寻64KB个内存单元。</p><p><strong>·段寄存器</strong></p><p>1）8086CPU有四个段寄存器：CS、DS、SS、ES。<br>2）CS：代码段寄存器（段地址），IP：指令指针寄存器（偏移地址）。<br>3）<img src="/2018/09/03/Assembly-language/8086PC读取执行指令关键部件.png" title="8086PC读取和执行指令的相关部件"><br>4）8086CPU工作过程：<br>   从CS:IP之乡的内存单元读取指令，指令进入指令缓冲区；<br>   IP = IP + 所读取的指令长度，从而指向下一条指令；<br>   执行指令。重复以上过程。<br>5）CPU只认被CS:IP指向的内存单元的内容为指令。</p><p><strong>·修改CS、IP的指令</strong></p><p>1）同时修改CS、IP的内容：“jmp 段地址：偏移地址”；<br>2）只修改IP的内容：“jmp 某一合法寄存器”（用寄存器里的值修改IP，eg: jmp ax）。</p><hr><h1 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h1><p><strong>·DS和[address]</strong></p><p>1）DS段寄存器通常来存放要访问的数据的段地址。<br>2）“[]”表示ds中的数据为内存单元的段地址，“[address]”中的“address”表示偏移地址。<br>3）假设读取10000H单元的内容（字节型数据的传送）：<br>   mov bx,1000H<br>   mov ds,bx<br>   mov <strong>al</strong>,[0]（使用mov指令将一个内存单元中的<strong>8位</strong>字节数据送入一个8位寄存器中）<br>   ds是段寄存器，不能直接传入1000H，只能用一个寄存器来进行中转。<br>4）字的传送：<br>   eg:<br>   mov bx,1000H<br>   mov ds,bx<br>   mov <strong>ax</strong>,[0]      ;1000：0处的<strong>16位</strong>字型数据送入ax<br>   mov [0],<strong>cx</strong>      ;将cx中的<strong>16位</strong>字数据传送到1000：0处</p><p><strong>·mov、add、sub指令</strong></p><p>1）这三个指令都带有两个操作对象。<br>2）以mov为例，mov、add、sub指令可以有以下几种形式：<br>   <strong>mov 寄存器，数据<br>   mov 寄存器，寄存器<br>   mov 寄存器，内存单元<br>   mov 内存单元，寄存器</strong><br>4）但是mov还存在以下四种形式：<br>   mov 段寄存器，寄存器<br>   mov 寄存器，段寄存器<br>   mov 内存单元，段寄存器<br>   mov 段寄存器，内存单元<br>5）add，sub指令不能对段寄存器进行操作。</p><p><strong>·栈</strong></p><p>1）栈是一种具有特殊访问方式的存储空间：最后进入这个空间的数据，最先出去（LIFO）。<br>2）入栈（push）和出栈（pop）都是以字为单位进行的。<br>3）<img src="/2018/09/03/Assembly-language/push和pop.png"><br>4）段寄存器SS：存放栈顶的段地址；寄存器SP：存放栈顶的偏移地址；<strong>任意时刻，SS:SP指向栈顶元素</strong>。<br>5）栈空，SS:SP指向栈空间最高地址单元的下一个单元。<br>6）一个数据出栈后，该地址单元的数据依然存在，只是不在栈中，当下次有数据入栈时，它将被覆盖。<br>7）8086CPU不保证对栈操作是否超界，栈顶超界将会覆盖栈外数据。</p><p><strong>·push和pop指令</strong></p><p>1）push指令和pop指令格式有如下形式（以push为例）：<br>   push 寄存器<br>   push 段寄存器<br>   push 内存单元<br>2）push指令执行步骤：（1）SP=SP-2；（2）向SS:SP指向的字单元送入数据。<br>3）pop指令执行步骤：（1）从SS:SP指向的字单元读取数据（2）SP=SP+2。<br>4）push和pop指令中修改的只是SP，所以栈顶的变化范围最大为：0-FFFFH。</p><p><strong>·段的综述</strong></p><p>1）将一段连续的内存定义为一个段，用段地址指示段，偏移地址访问段内单元，数据段、代码段、栈段都是我们自己定义的。<br>2）数据段：段地址存放在DS中，用mov,add,sub等访问内存单元的指令时，CPU数据段的内容当作数据访问。<br>3）代码段：段地址存放在CS中，段中第一条指令的偏移地址放在IP中，CPU就执行代码段中的指令。<br>4）栈段：段地址存放在SS中，栈顶单元的偏移地址放在SP中，CPU执行栈操作时将我们定义的栈段当作占空间来用。<br>5）同一段内存，同时可以是代码段、栈段和数据段，也可以什么都不是，关键在于CS、IP、SS、SP、DS的指向。</p><hr><h1 id="初识汇编程序"><a href="#初识汇编程序" class="headerlink" title="初识汇编程序"></a>初识汇编程序</h1><p><strong>·3个伪指令</strong></p><p>1）segment和ends伪指令：这是一对成对使用的伪指令，作用是定义一个段毒啊，其格式为：<br>   段名 segment    ；段从此处开始<br>       :<br>   段名 ends       ；段到此处结束<br>2）程序是由多个段组成的，指令、数据、栈被划分到了不同的段中。<br>3）end：汇编程序结束标记。<br>4）assume：假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联，例如：<br>   assume cs: 代码段的名字 将一个代码段和CS寄存器联系起来。</p><p><strong>·程序返回</strong></p><p>1）指令：<br>   mov ax,4c00H<br>   int 21H</p><hr><h1 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h1><p><strong>·约定两个符号</strong></p><p>1）“（ ）”：表示一个寄存器或者内存单元里的内容。<br>2）“idata”：表示常量。</p><p><strong>·[BX]</strong></p><p>1）同[0]一样，[bx]也表示一个内存单元，只是它的偏移地址在bx中。<br>2）bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中。</p><p><strong>·Loop指令</strong></p><p>1）loop指令格式：loop 标号；<strong>通常</strong>用loop指令来实现循环功能，cx中存放循环次数。<br>2）eg:<br>   mov ax,2<br>   mov cx,11<br>s: add ax,ax<br>   loop s<br>   mov ax,4c00h<br>   int 21h<br>3）标号代表一个地址，如上例s标识了一个地址，这个地址处有一条指令：add ax,ax.<br>4）CPU执行 loop s 的时候，进行两步操作：<br>   （1）（cx）=（cx）- 1<br>   （2）判断cx中的值，不为0则转至标号s所标识的地址处执行，如果为零则执行下一条指令。</p><p><strong>·汇编程序中的一些小变动</strong></p><p>1）用一个长度位1字节地内存单元向16位寄存器赋值（如把ffff:0006单元给ax赋值），则应该另令(ah)=0,(al)=(ffff6H)。<br>2）在汇编程序中，数据不能以字母开头，例如代码中mov ax,0ffffh，不能写成mov ax,ffffh。<br>3）汇编程序中，指令“mov ax,[0]”被当作“mov ax,0”处理，因此有如下两种方法实现将内存单元中的数据送入寄存器（举例说明）：<br>   mov al,ds:[0]<br>   mov al,[bx]<br>   mov al,ds:[bx]</p><p><strong>·段前缀</strong></p><p>1）出现在访问内存单元的指令中，用于显式地指明内存单元的段地址，形如“mov al,ds:[bx]”，在汇编语言中称为段前缀。<br>2）将一段内存单元的数据复制到另一段单元中，显式使用段前缀，可以提高程序效率。</p><hr><h1 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h1><p><strong>·在代码段中使用数据</strong></p><p>1）end的另一作用：指明编译器程序入口，用法：end 标号<br>2）在代码段中使用数据可以使用如下程序框架：<br>   assume cs:code<br>   code segment<br>           :<br>           :<br>           数据<br>           :<br>           :<br>   start:<br>           :<br>           :<br>           代码<br>           :<br>           :<br>   code ends<br>   end start<br>   来指明CPU从何处开始执行程序。</p><p><strong>·在代码段中使用栈</strong></p><p>1）在代码段中使用栈挥着数据实质上都是开辟空间。<br>2）在代码段中使用栈可以使用如下程序框架：<br>   assume cs:code<br>   code segment<br>           :<br>           :<br>           数据<br>           栈空间<br>           :<br>           :<br>   start:<br>           :<br>           :<br>           代码<br>           :<br>           :<br>   code ends<br>   end start<br>   来指明CPU从何处开始执行程序。</p><p><strong>·将数据、代码、栈放入不同的段</strong></p><p>1）定义多个段。eg：<br>   assume cs:code,ds:data,ss:stack<br>2）对段地址的引用：段名就相当于标号，它代表了段地址。eg:<br>   mov ax,data ;将名称为“data”的段地址送入ax。<br>3）<img src="/2018/09/03/Assembly-language/多个段举例.png" title="举例"></p><hr><h1 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h1><p><strong>·and和or指令</strong></p><p>1）and指令：逻辑与指令，按位进行与运算。该指令可以将操作对象的相应位设为0，其他位不变。<br>2）or指令：逻辑或指令，按位进行或运算。该指令可以将操作对象的相应位设为1，其他未不变。<br>3）eg:<br>   mov al,01100011B<br>   and al,00111011B    执行后al=00100011B</p><p>   mov al,01100011B<br>   or  al,00111011B    执行后al=01111011B</p><p><strong>·以字符形式给出的数据</strong></p><p>1）用’……’的方式指明数据是以字符的形式给出的，编译器将其转化为ASCII码。<br>2）eg:<br>   db ‘unIX’     ；相当于“db 75H,6EH,49H,58H”<br>   mov al,’a’    ；相当于“mov al,61H”</p><p><strong>·大小写转换问题</strong></p><p>1）除了大写字母=小写字母-20H外，可以用and 11011111B将小写转换为大写字母。<br>2）可用or 01100000B将大写转换为小写字母。</p><p><strong>·[bx+idata]</strong></p><p>1）[bx+idata]表示一个偏移地址为(bx)+idata的内存单元。<br>2）常用格式：<br>   mov ax,[bx+idata]<br>   mov ax,[idata+bx]<br>   mov ax,idata[bx]<br>   mov ax,[bx].idata<br>3）[bx+idata]的方式处理数组更加便利。与C语言比较：<br>   C语言：a[i],b[i]<br>   汇编语言：0[bx],5[bx]</p><p><strong>·SI和DI</strong></p><p>1）si和di是8086CPU中和bx功能相近的寄存器，si和di不能分成两个8位寄存器来使用。<br>2）复制字符串汇编程序举例：<br>   <img src="/2018/09/03/Assembly-language/sidi举例1.png"><br>   <img src="/2018/09/03/Assembly-language/sidi举例2.png"></p><p><strong>·[bx+si]和[bx+di]</strong></p><p>1）[bx+si]和[bx+di]含义相似，以[bx+si]为例，其表示一个偏移地址位(bx)+(si)的内存单元。</p><p><strong>·[bx+si+idata]和[bx+di+idata]</strong></p><p>1）[bx+si+idata]和[bx+di+idata]含义相似，以[bx+si+idata]为例，其表示一个偏移地址位(bx)+(si)+idata的内存单元。<br>2）常用格式：<br>   mov ax,[bx+idata+si]<br>   mov ax,[idata+bx+si]<br>   mov ax,idata[bx][si]<br>   mov ax,[bx].idata[si]<br>   mov ax,[bx][si].200</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;初学汇编语言的笔记，方便日后深入学习。该博客知识来自《汇编语言》王爽&lt;/center&gt;
    
    </summary>
    
      <category term="Language" scheme="http://yoursite.com/categories/Language/"/>
    
    
      <category term="assembly language" scheme="http://yoursite.com/tags/assembly-language/"/>
    
  </entry>
  
</feed>
