<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>asKylin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-06T09:56:27.448Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>doubleheiker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Assembly language</title>
    <link href="http://yoursite.com/2018/09/03/Assembly-language/"/>
    <id>http://yoursite.com/2018/09/03/Assembly-language/</id>
    <published>2018-09-03T11:18:35.000Z</published>
    <updated>2018-09-06T09:56:27.448Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>·汇编语言的组成（3类指令）</strong></p><p>1）汇编指令：有对应的机器码。<br>2）伪指令：没有对应的机器码，由编译器执行。<br>3）其他符号：如+、-、*、/等，没有对应的机器码，由编译器执行。</p><p><strong>·CPU对存储器的读写</strong></p><p>与芯片进行3类信息的交互：<br>1）存储单元地址。<br>2）器件选择，读或写命令。<br>3）读或写的数据。</p><p><strong>·外部总线</strong></p><p>1）地址总线：N根地址线可以选找2的N次方个内存单元（一个内存单元1byte）。<br>2）数据总线：宽度为8k的总线一次能传送 k Btye的数据。<br>3）控制总线：宽度决定CPU对外部期间的控制能力。</p><p><strong>·存储器芯片</strong></p><p>1）随机存储（RAM）：可读可写，关机数据丢失。<br>2）只读存储（ROM）：只读，关机数据不丢失。</p><hr><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><strong>·Registers Architecture(寄存器结构)</strong></p><style>table th:nth-of-type(2) {    width: 100px;}table th:nth-of-type(3) {    width: 60px;}table th:nth-of-type(9) {    width: 80px;}</style> <table><thead><tr><th>register</th><th style="text-align:center">Accumulator</th><th>Counter</th><th>Data</th><th>Base</th><th>Stack Pointer</th><th>Stack Base Pointer</th><th>Source</th><th>Destination</th></tr></thead><tbody><tr><td>64-bit</td><td style="text-align:center">RAX</td><td>RCX</td><td>RDX</td><td>RBX</td><td>RSP</td><td>RBP</td><td>RSI</td><td>RCI</td></tr><tr><td>32-bit</td><td style="text-align:center">EAX</td><td>ECX</td><td>EDX</td><td>EBX</td><td>ESP</td><td>EBP</td><td>ESI</td><td>EDI      </td></tr><tr><td>16-bit</td><td style="text-align:center">AX</td><td>CX</td><td>DX</td><td>BX</td><td>SP</td><td>BP</td><td>SI</td><td>DI</td></tr><tr><td> 8-bit</td><td style="text-align:center">AH/AL</td><td>CH/CL</td><td>DH/DL</td><td>BH/BL</td></tr></tbody></table><p><strong>·通用寄存器</strong></p><p>1）AX BX CX DX 这四个寄存器存放一般性数据。<br>2）这四个通用寄存器都可以分为两个八位寄存器使用（参见上表16-bit和8-bit）<br>   其中，低八位构成AL，高八位构成AH。</p><p><strong>·几条汇编指令</strong><br>1）汇编指令举例</p><style>table th:first-of-type {    width: 100px;}table th:nth-of-type(2) {    width: 100px;}</style> <table><thead><tr><th>汇编指令</th><th style="text-align:center">控制CPU完成的操作</th></tr></thead><tbody><tr><td>mov ax,18</td><td style="text-align:center">AX=18</td></tr><tr><td>mov ah,78</td><td style="text-align:center">AH=78</td></tr><tr><td>mov al,8</td><td style="text-align:center">AL=8</td></tr><tr><td>add ax,9</td><td style="text-align:center">AX+=9</td></tr><tr><td>mov ax,bx</td><td style="text-align:center">AX=BX</td></tr><tr><td>mov al,bh</td><td style="text-align:center">AL=BH</td></tr><tr><td>add ax,bx</td><td style="text-align:center">AX+=BX</td></tr><tr><td>add bh,al</td><td style="text-align:center">BH+=AL</td></tr></tbody></table><p>2）注意事项：<br>   16位寄存器中，若是数据值相加超过4位十六进制的数据，则只保存低四位的十六进制数据。<br>   当16位寄存器被用作两个八位寄存器时，若寄存器数据值超过两位十六进制的数据，则只保存低二位的十六进制数据（若是AL寄存器中数据超过内存，高位不是真的被CPU丢失）<br>   指令的两个操作对象的位数应该一致，而：<br>      mov ax,bl<br>      mov bh,ax<br>      mov al,2000（超出范围）<br>      add al,100H（超出范围）<br>   都是错误的指令。</p><p><strong>·8086CPU给出物理地址的方法</strong></p><p>1）地址加法器采用<strong>物理地址 = 段地址x16 + 偏移地址</strong>的方法（地址数据用16进制表示）。<br>2）基础地址 = 段地址 x 16。<br>3）“段地址x16”实际上表示16进制数左移一位（即二进制数左移4位）。</p><p><strong>·段地址</strong></p><p>1）“段地址”划分来自CPU，不是内存本身分段。<br>2）CPU可以用不同的段地址和偏移地址形成同一个物理地址。<br>3）给定段地址，仅用偏移地址寻址最多可寻64KB个内存单元。</p><p><strong>·段寄存器</strong></p><p>1）8086CPU有四个段寄存器：CS、DS、SS、ES。<br>2）CS：代码段寄存器（段地址），IP：指令指针寄存器（偏移地址）。<br>3）<img src="/2018/09/03/Assembly-language/8086PC读取执行指令关键部件.png" title="8086PC读取和执行指令的相关部件"><br>4）8086CPU工作过程：<br>   从CS:IP之乡的内存单元读取指令，指令进入指令缓冲区；<br>   IP = IP + 所读取的指令长度，从而指向下一条指令；<br>   执行指令。重复以上过程。<br>5）CPU只认被CS:IP指向的内存单元的内容为指令。</p><p><strong>·修改CS、IP的指令</strong></p><p>1）同时修改CS、IP的内容：“jmp 段地址：偏移地址”；<br>2）只修改IP的内容：“jmp 某一合法寄存器”（用寄存器里的值修改IP，eg: jmp ax）。</p><hr><h1 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h1><p><strong>·DS和[address]</strong></p><p>1）DS段寄存器通常来存放要访问的数据的段地址。<br>2）“[]”表示ds中的数据为内存单元的段地址，“[address]”中的“address”表示偏移地址。<br>3）假设读取10000H单元的内容（字节型数据的传送）：<br>   mov bx,1000H<br>   mov ds,bx<br>   mov <strong>al</strong>,[0]（使用mov指令将一个内存单元中的<strong>8位</strong>字节数据送入一个8位寄存器中）<br>   ds是段寄存器，不能直接传入1000H，只能用一个寄存器来进行中转。<br>4）字的传送：<br>   eg:<br>   mov bx,1000H<br>   mov ds,bx<br>   mov <strong>ax</strong>,[0]      ;1000：0处的<strong>16位</strong>字型数据送入ax<br>   mov [0],<strong>cx</strong>      ;将cx中的<strong>16位</strong>字数据传送到1000：0处</p><p><strong>·mov、add、sub指令</strong></p><p>1）这三个指令都带有两个操作对象。<br>2）以mov为例，mov、add、sub指令可以有以下几种形式：<br>   <strong>mov 寄存器，数据<br>   mov 寄存器，寄存器<br>   mov 寄存器，内存单元<br>   mov 内存单元，寄存器</strong><br>4）但是mov还存在以下四种形式：<br>   mov 段寄存器，寄存器<br>   mov 寄存器，段寄存器<br>   mov 内存单元，段寄存器<br>   mov 段寄存器，内存单元<br>5）add，sub指令不能对段寄存器进行操作。</p><p><strong>·栈</strong></p><p>1）栈是一种具有特殊访问方式的存储空间：最后进入这个空间的数据，最先出去（LIFO）。<br>2）入栈（push）和出栈（pop）都是以字为单位进行的。<br>3）<img src="/2018/09/03/Assembly-language/push和pop.png"><br>4）段寄存器SS：存放栈顶的段地址；寄存器SP：存放栈顶的偏移地址；<strong>任意时刻，SS:SP指向栈顶元素</strong>。<br>5）栈空，SS:SP指向栈空间最高地址单元的下一个单元。<br>6）一个数据出栈后，该地址单元的数据依然存在，只是不在栈中，当下次有数据入栈时，它将被覆盖。<br>7）8086CPU不保证对栈操作是否超界，栈顶超界将会覆盖栈外数据。</p><p><strong>·push和pop指令</strong></p><p>1）push指令和pop指令格式有如下形式（以push为例）：<br>   push 寄存器<br>   push 段寄存器<br>   push 内存单元<br>2）push指令执行步骤：（1）SP=SP-2；（2）向SS:SP指向的字单元送入数据。<br>3）pop指令执行步骤：（1）从SS:SP指向的字单元读取数据（2）SP=SP+2。<br>4）push和pop指令中修改的只是SP，所以栈顶的变化范围最大为：0-FFFFH。</p><p><strong>·段的综述</strong></p><p>1）将一段连续的内存定义为一个段，用段地址指示段，偏移地址访问段内单元，数据段、代码段、栈段都是我们自己定义的。<br>2）数据段：段地址存放在DS中，用mov,add,sub等访问内存单元的指令时，CPU数据段的内容当作数据访问。<br>3）代码段：段地址存放在CS中，段中第一条指令的偏移地址放在IP中，CPU就执行代码段中的指令。<br>4）栈段：段地址存放在SS中，栈顶单元的偏移地址放在SP中，CPU执行栈操作时将我们定义的栈段当作占空间来用。<br>5）同一段内存，同时可以是代码段、栈段和数据段，也可以什么都不是，关键在于CS、IP、SS、SP、DS的指向。</p><hr><h1 id="初识汇编程序"><a href="#初识汇编程序" class="headerlink" title="初识汇编程序"></a>初识汇编程序</h1><p><strong>·3个伪指令</strong></p><p>1）segment和ends伪指令：这是一对成对使用的伪指令，作用是定义一个段毒啊，其格式为：<br>   段名 segment    ；段从此处开始<br>       :<br>   段名 ends       ；段到此处结束<br>2）程序是由多个段组成的，指令、数据、栈被划分到了不同的段中。<br>3）end：汇编程序结束标记。<br>4）assume：假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联，例如：<br>   assume cs: 代码段的名字 将一个代码段和CS寄存器联系起来。</p><p><strong>·程序返回</strong></p><p>1）指令：<br>   mov ax,4c00H<br>   int 21H</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;初学汇编语言的笔记，方便日后深入学习。&lt;/center&gt;
    
    </summary>
    
      <category term="Language" scheme="http://yoursite.com/categories/Language/"/>
    
    
      <category term="assembly language" scheme="http://yoursite.com/tags/assembly-language/"/>
    
  </entry>
  
</feed>
